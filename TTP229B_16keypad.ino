// TTP229-BSF based 16-key pad
//
// Connection
// Keypad <-> Arduino Leonardo (check interrupts according to Arduino.cc reference and change accordingly either interrupt number or connection pins)
// VCC <----> 5V <--> +5V power supply
// GND <----> GND <-> Ground reference
// SCL <----> D3 <--> Serial clock (generated by Arduino)
// SDO <----> D2 <--> Serial data and Data Valid signal (generated by TTP229)
// EINT <---> D1 <--> Data Valid signal

// We have 3 states
enum State {
  Waiting = 0, // Waiting for keypress and Data Valid signal from touchpad
  DataCooking, // Got Data Valid signal start, now waiting for Data Valid signal end
  DataReady    // Got properly timed Data Valid signal end, so we can now read which key was pressed
};

volatile State state = Waiting;

unsigned int buttonMap[16];

void setup() {
  // pregenerate button mapping to save processor resources later
  for (int i = 0; i < 16; i++)
  {
    buttonMap[15 - i] = 1 << i;
  }
  Serial.begin(9600);
  pinMode(2, INPUT);
  pinMode(3, OUTPUT);
  attachInterrupt(1, onRise, RISING);
}

volatile unsigned long cookingTime = 0;

void loop() {

	checkKeyState();
}

void checkKeyState() {
	  switch (state)
  {
    case Waiting:
    {
      break;
    }
    case DataCooking:
    {
      unsigned long checkTime = micros();
      // According to Datasheet, TTP229 should issue Data Valid signal of length 93 uS, but we can make a little over for sure
      if (checkTime - cookingTime > 150)
      {
        detachInterrupt(1);
        state = Waiting;
        attachInterrupt(1, onRise, RISING);
      }
      break;
    }
    case DataReady:
    {
      unsigned int first = shiftIn(2, 3, MSBFIRST);
      unsigned int second = shiftIn(2, 3, MSBFIRST);
      unsigned int buttonMask = (first << 8) + second;
      if (buttonMask > 0) {
        for (int i = 0; i < 16; i++)
        {
          if (buttonMask == buttonMap[i])
          {
            Serial.print("Button ");
            Serial.print(i + 1, DEC);
            Serial.println(" pressed");
          }
        }
      }
      else
      {
        Serial.println("All buttons released");
      }
      state = Waiting;
      attachInterrupt(1, onRise, RISING);
      break;
    }
  }
}

void onRise()
{
  state = DataCooking;
  cookingTime = micros();
  detachInterrupt(1);
  attachInterrupt(1, onFall, FALLING);
}

void onFall()
{
  state = DataReady;
  detachInterrupt(1);
}

